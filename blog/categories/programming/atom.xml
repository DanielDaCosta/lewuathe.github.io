<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | The first cry of Atom]]></title>
  <link href="http://lewuathe.github.io/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://lewuathe.github.io/"/>
  <updated>2014-06-19T20:12:01+09:00</updated>
  <id>http://lewuathe.github.io/</id>
  <author>
    <name><![CDATA[Kai Sasaki]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Next Tile on Tempai]]></title>
    <link href="http://lewuathe.github.io/blog/2014/03/19/next-tile-on-tempai/"/>
    <updated>2014-03-19T22:57:59+09:00</updated>
    <id>http://lewuathe.github.io/blog/2014/03/19/next-tile-on-tempai</id>
    <content type="html"><![CDATA[<p>I tried <a href="http://www.itmedia.co.jp/enterprise/articles/1004/03/news002_2.html">this problem</a>.</p>

<p>Your program receives the hand of mahjong. Returns the &ldquo;Waiting style&rdquo; of this hand.
But there are some conditions as below.</p>

<ul>
<li>There are no <em>Jihai</em>, only <em>Manzu</em></li>
<li>Make <em>Juntsu</em>, <em>Kohtsu</em> and <em>Head</em></li>
<li>Regard different order waiting as the same</li>
<li>If there are no waiting, no output</li>
</ul>


<!-- more -->


<p>My source code are pushed <a href="https://github.com/Lewuathe/java-GoF/blob/master/AtCoder/MahjongWait/src/Main.java">this repository</a></p>

<p>```java
import java.util.Scanner;</p>

<p>/<em>*
 * Created by Kai Sasaki on 3/19/14.
 </em>/
public class Main {</p>

<pre><code>public static void search(int tiles[], boolean isHead, String ans, int order) {
    for (int i = 0; i &lt; 9; i++) {
        if (tiles[i] &gt;= 3) {
            // In order to remove practical same hands,
            // this operation should be done before bigger values
            if (i + 1 &lt; order) {
                return;
            }

            // In order to remove practical same hands,
            // this operation should be done before finding head
            if (isHead) {
                return;
            }

            // Find *Kohtsu*
            int tmp[] = tiles.clone();
            tmp[i] -= 3;
                                                                                                                                                                                             String tmpAns = ans + String.format("(%d%d%d)", i + 1, i + 1, i + 1);
            search(tmp, isHead, tmpAns, i + 1);
        }
    }

    for (int i = 0; i &lt; 7; i++) {
        if (tiles[i] &gt;= 1 &amp;&amp; tiles[i + 1] &gt;= 1 &amp;&amp; tiles[i + 2] &gt;= 1) {
            // In order to remove practical same hands,
            // this operation should be done before bigger values
            if (i + 1 &lt; order) {
                return;
            }

            // In order to remove practical same hands,
            // this operation should be done before finding head
            if (isHead) {
                return;
            }

            // Find *Juntsu*
            int tmp[] = tiles.clone();
            tmp[i] -= 1;
            tmp[i + 1] -= 1;
            tmp[i + 2] -= 1;
            String tmpAns = ans + String.format("(%d%d%d)", i + 1, i + 2, i + 3);
            search(tmp, isHead, tmpAns, i + 1);
        }
    }

    for (int i = 0; i &lt; 9; i++) {
        if (tiles[i] &gt;= 2 &amp;&amp; !isHead) {
            if (i + 1 &lt; order) {
                return;
            }

            // Find head
            int tmp[] = tiles.clone();
            tmp[i] -= 2;
            String tmpAns = ans + String.format("(%d%d)", i + 1, i + 1);
            search(tmp, true, tmpAns, i + 1);
        }
    }

    // No more mentsu
    int oneCount = 0;
    int twoCount = 0;
    int sum = 0;
    for (int i = 0; i &lt; 9; i++) {
       sum += tiles[i];
       if (tiles[i] == 1) {
           oneCount += 1;
       } else if (tiles[i] == 2) {
           twoCount += 1;
       }
    }

    // 000100000
    if (oneCount == 1 &amp;&amp; sum == 1) {
        for (int i = 0; i &lt; 9; i++) {
            if (tiles[i] == 1) {
                ans += String.format("[%d]", i + 1);
                System.out.println(ans);
                return;
            }
        }
    }

    // 000001100
    if (oneCount == 2 &amp;&amp; sum == 2) {
        for (int i = 0; i &lt; 8; i++) {
            if (tiles[0] == 1 &amp;&amp; tiles[1] == 1) {
                ans += "[12]";
                System.out.println(ans);
                return;
            } else if (tiles[7] == 1 &amp;&amp; tiles[8] == 1) {
                ans += "[89]";
                System.out.println(ans);
                return;
            } else if (tiles[i] == 1 &amp;&amp; tiles[i + 1] == 1) {
                ans += String.format("[%d%d]", i + 1, i + 2);
                System.out.println(ans);
                return;
            }
       }
    }

    if (twoCount == 1 &amp;&amp; sum == 2) {
        for (int i = 0; i &lt; 9; i++) {
            if (tiles[i] == 2) {
                ans += String.format("[%d%d]", i + 1, i + 1);
                System.out.println(ans);
                return;
            }
        }
    }
    return;
}

public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);

    // Receive string that represents hand values
    String hand = sc.next();

    int tiles[] = new int[9];

    // Initialization
    for (int i = 0; i &lt; 9; i++) {
        tiles[i] = 0;
    }

    // Setting tiles array
    for (int i = 0; i &lt; 13; i++) {
        Integer tile = Integer.parseInt("" + hand.charAt(i));
        tiles[tile - 1] += 1;
    }

    search(tiles, false, "", 1);
}
</code></pre>

<p>}
```</p>

<p>This is the simple depth first search algorithm. Ths main point of this code is in the
main method. I expressed the data structure that represents <em>Hand</em> as the interger array.
Each integer corresponds to the count of each tile. So in order to calculate the waiting tile,
in this case, all you have to know is the count of each tile. With this data structure, you don&rsquo;t
need to retain complex structure. And also the operation such as finding <em>Juntsu</em> and so on is easy
to execute bacause only increment or decrement of each value of this array.</p>

<p>It took me a long time but thanks to this training, a search algorithm such as <a href="http://en.wikipedia.org/wiki/Depth-first_search">DFS</a>
is no more alien to me. It&rsquo;s friend!</p>

<p>Thank you.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM144 Div1]]></title>
    <link href="http://lewuathe.github.io/blog/2014/03/17/srm144-div1/"/>
    <updated>2014-03-17T21:57:38+09:00</updated>
    <id>http://lewuathe.github.io/blog/2014/03/17/srm144-div1</id>
    <content type="html"><![CDATA[<p>After a long time, I returned to <a href="http://www.topcoder.com/">TopCoder</a>.
I forgot to write algorithm for programming contest such as TopCoder. But previously
I realized that it is so important for me to write accurate and fast algorithm within finite time.
In order to improve my programming skill again, I returned back to the TopCoder.</p>

<!-- more -->


<p>SRM is a little hart to me, as first, I tried some practices. Today I solved SRM144 binary code problem.
This problem decode messages recursively. For example, when you get the message <code>"123210122"</code>, this is encode of
<code>"011100011"</code>. Suppose the first message is P, and second is Q. Now below equation is realized.</p>

<p><code>
P[i] = Q[i-1] + Q[i] + Q[i+1]
</code></p>

<p>With this recusive rule, you have to decode given message. My code is below.</p>

<p>```java
import java.util.<em>;
import java.math.</em>;</p>

<p>import static java.lang.Math.*;</p>

<p>public class BinaryCode {</p>

<pre><code>public String[] decode(String message) {
    // Two answers should be solved
    // Each answer is correspond to Q[0] = 0 and Q[0] = 1 case.
    String[] ans = new String[2];

    Integer start = 0;
    Boolean isOut = null;

    // Calculate two cases
    for (int i = 0; i &lt; 2; i++) {
        // In the case of negative value is received, answer should be "NONE"
        isOut = false;
        start = i;

        // For improve speed performance, I use StringBuffer
        StringBuffer p = new StringBuffer();

        // First and second factor cannot be put on inside loop bacause these are not the sum of three factors
        p.append(start.toString());
        Integer p1 = Integer.parseInt(message.substring(0, 1)) - Integer.parseInt(p.substring(0, 1));
        p.append(p1);

        // Decode each digit
        for (int j = 1; j &lt; message.length(); j++) {
            Integer d = Integer.parseInt(message.substring(j, j+1)) - Integer.parseInt(p.substring(j, j+1)) - Integer.parseInt(p.substring(j-1, j));
            if (d &lt; 0) {
                ans[i] = "NONE";
                isOut = true;
                break;
            }
            p.append(d.toString());
       }

       // Last digit is not need to retained
       if (!isOut) {
           ans[i] = p.toString().substring(0, p.length()-1);
       }

       // This is guard. But I am not satisfied with this line :(
       if (message.length() == 1 &amp;&amp; (message.charAt(0) == '2' || message.charAt(0) == '3')) {
           ans[i] = "NONE";
       }
    }

    return ans;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>I wrote this code about 30 minutes. It is not enough to fight on SRM. And in addition to this, I am not satisfied with my algorithm expecially
last clause. I don&rsquo;t want to write exceptional logic as possible. If anyone write code about this problem, please inform me and give me a chance to
look into your code.</p>

<p>Thank you.</p>
]]></content>
  </entry>
  
</feed>
