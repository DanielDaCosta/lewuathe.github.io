<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | The first cry of Atom]]></title>
  <link href="http://lewuathe.github.io/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://lewuathe.github.io/"/>
  <updated>2014-03-17T22:34:40+09:00</updated>
  <id>http://lewuathe.github.io/</id>
  <author>
    <name><![CDATA[Kai Sasaki]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM144 Div1]]></title>
    <link href="http://lewuathe.github.io/blog/2014/03/17/srm144-div1/"/>
    <updated>2014-03-17T21:57:38+09:00</updated>
    <id>http://lewuathe.github.io/blog/2014/03/17/srm144-div1</id>
    <content type="html"><![CDATA[<p>After a long time, I returned to <a href="http://www.topcoder.com/">TopCoder</a>.
I forgot to write algorithm for programming contest such as TopCoder. But previously
I realized that it is so important for me to write accurate and fast algorithm within finite time.
In order to improve my programming skill again, I returned back to the TopCoder.</p>

<!-- more -->


<p>SRM is a little hart to me, as first, I tried some practices. Today I solved SRM144 binary code problem.
This problem decode messages recursively. For example, when you get the message <code>"123210122"</code>, this is encode of
<code>"011100011"</code>. Suppose the first message is P, and second is Q. Now below equation is realized.</p>

<p><code>
P[i] = Q[i-1] + Q[i] + Q[i+1]
</code></p>

<p>With this recusive rule, you have to decode given message. My code is below.</p>

<p>```java
import java.util.<em>;
import java.math.</em>;</p>

<p>import static java.lang.Math.*;</p>

<p>public class BinaryCode {</p>

<pre><code>public String[] decode(String message) {
    // Two answers should be solved
    // Each answer is correspond to Q[0] = 0 and Q[0] = 1 case.
    String[] ans = new String[2];

    Integer start = 0;
    Boolean isOut = null;

    // Calculate two cases
    for (int i = 0; i &lt; 2; i++) {
        // In the case of negative value is received, answer should be "NONE"
        isOut = false;
        start = i;

        // For improve speed performance, I use StringBuffer
        StringBuffer p = new StringBuffer();

        // First and second factor cannot be put on inside loop bacause these are not the sum of three factors
        p.append(start.toString());
        Integer p1 = Integer.parseInt(message.substring(0, 1)) - Integer.parseInt(p.substring(0, 1));
        p.append(p1);

        // Decode each digit
        for (int j = 1; j &lt; message.length(); j++) {
            Integer d = Integer.parseInt(message.substring(j, j+1)) - Integer.parseInt(p.substring(j, j+1)) - Integer.parseInt(p.substring(j-1, j));
            if (d &lt; 0) {
                ans[i] = "NONE";
                isOut = true;
                break;
            }
            p.append(d.toString());
       }

       // Last digit is not need to retained
       if (!isOut) {
           ans[i] = p.toString().substring(0, p.length()-1);
       }

       // This is guard. But I am not satisfied with this line :(
       if (message.length() == 1 &amp;&amp; (message.charAt(0) == '2' || message.charAt(0) == '3')) {
           ans[i] = "NONE";
       }
    }

    return ans;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>I wrote this code about 30 minutes. It is not enough to fight on SRM. And in addition to this, I am not satisfied with my algorithm expecially
last clause. I don&rsquo;t want to write exceptional logic as possible. If anyone write code about this problem, please inform me and give me a chance to
look into your code.</p>

<p>Thank you.</p>
]]></content>
  </entry>
  
</feed>
