<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Competitive Programming | The first cry of Atom]]></title>
  <link href="http://lewuathe.github.io/blog/categories/competitive-programming/atom.xml" rel="self"/>
  <link href="http://lewuathe.github.io/"/>
  <updated>2014-05-26T21:35:33+09:00</updated>
  <id>http://lewuathe.github.io/</id>
  <author>
    <name><![CDATA[Kai Sasaki]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Patterns About BFS in Competitive Programming]]></title>
    <link href="http://lewuathe.github.io/blog/2014/04/10/patterns-about-bfs-in-commetitive-programming/"/>
    <updated>2014-04-10T20:24:26+09:00</updated>
    <id>http://lewuathe.github.io/blog/2014/04/10/patterns-about-bfs-in-commetitive-programming</id>
    <content type="html"><![CDATA[<p>So let&rsquo;s go back to English from today :)</p>

<p>I solved SRM612 Div1 for practice. This problem is <a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=10543">this</a>
In this post, I left out the detail of this problem because main topic of this post is pattern of <a href="http://en.wikipedia.org/wiki/Breadth-first_search">BFS</a>.
First I tried to solve this problem with some dynamic programming algorithm. But after trying, I found BFS is sufficient algorithm
to solve. So now I rewrote my program as below.</p>

<!-- more -->


<p>```java
import java.util.<em>;
import java.math.</em>;</p>

<p>import static java.lang.Math.*;</p>

<p>public class EmoticonsDiv1 {</p>

<pre><code>public static int[] decode(int code) {
    int[] ret = new int[2];
    ret[0] = code / 10000;
    ret[1] = code % 10000;
    return ret;
}

public int printSmiles(int smiles) {
    Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;();
    int[][] state = new int[1 &lt;&lt; 1000][1 &lt;&lt; 1000];
    for (int i = 0; i &lt; 1 &lt;&lt; 1000; i++) {
        for (int j = 0; j &lt; 1 &lt;&lt; 1000; j++) {
            state[i][j] = (1 &lt;&lt; 1000);
        }
    }
</code></pre>

<p>//        state[i][j] : i = message, j = clipboard</p>

<pre><code>    state[1][0] = 0;
    q.add(1 * 10000 + 0);

    while (!q.isEmpty()) {
        int[] ret = decode(q.poll());
        int message = ret[0];
        int clipboard = ret[1];

        if (state[message][message] &gt; state[message][clipboard] + 1) {
            state[message][message] = state[message][clipboard] + 1;
            q.add(message * 10000 + message);
        }

        if (message + clipboard &lt; (1 &lt;&lt; 1000) &amp;&amp; state[message + clipboard][clipboard] &gt; state[message][clipboard] + 1) {
            state[message + clipboard][clipboard] = state[message][clipboard] + 1;
            if (message + clipboard == smiles) return state[message + clipboard][clipboard];
            q.add((message + clipboard) * 10000 + clipboard);
        }

        if (message &gt; 0 &amp;&amp; state[message - 1][clipboard] &gt; state[message][clipboard] + 1) {
            state[message - 1][clipboard] = state[message][clipboard] + 1;
            if (message - 1 == smiles) return state[message - 1][clipboard];
            q.add((message - 1) * 10000 + clipboard);
        }

    }

    return 1 &lt;&lt; 1000;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>The computing complexity of this code is O(S<sup>2</sup>). Could solve in time. After writing, I realized there are some patterns about writing BFS
in competitive programming. I want to put together these patterns in this port for the future contest.</p>

<h2>State encoding, decoding</h2>

<p>In general, BFS uses a queue data strucure. The elements of queue has to keep each state to search. In this case, each <code>message</code> and <code>clipboard</code>.
When you write software on long-term basis, you should write state class for keeping <code>message</code> and <code>clipboard</code>. But this is competitive programming.
Defining adhoc class will take you some more time to complete writing code. So you should avoid this pattern as possible.</p>

<p>The solution is encoding, decoding pattern. Default queue can only keep one <code>Integer</code> or <code>String</code>, therefore let two variables put into this one variable.
Specifically, this is.</p>

<p>```java
// Decode one integer to two interger that composes state
public static int[] decode(int code) {</p>

<pre><code>int[] ret = new int[2];
ret[0] = code / 10000;
ret[1] = code % 10000;
return ret;
</code></pre>

<p>}</p>

<p>int[] ret = decode(q.poll());
int message = ret[0];
int clipboard = ret[1];
// Encode two variables into one variable
q.add(message * 10000 + clipboard);</p>

<p>```</p>

<p>With this pattern you don&rsquo;t have to write your own state class. But this pattern has a fault. If there are more variables in a state,
decoding and encoding code becomes more complex and hard to debug. In addition to this problem, you should also know the range of input variable.
In this case, I use 10000 number to encoding and decoding, bacause input variables are included in [0, 1000]. So <code>message</code> and <code>clipboard</code> can be
separated. The selection of this base integer will be difficult as the number of state varibales are increasing.</p>

<h2>Optimization value</h2>

<p>Above case, optimization value to be submit as answer is the count of manipulation <code>state[i][j]</code>. If you can write state class, you don&rsquo;t need to
this 2 dimension array. But you couldn&rsquo;t. So with this <code>state</code>, I can realize that if I want to keep more values such as optimization value,
I can prepair external third variable instead. With this variable, you can keep more values corresponding to each state.</p>

<h2>Last but not least</h2>

<p>You should not write such codes in production software!!</p>
]]></content>
  </entry>
  
</feed>
