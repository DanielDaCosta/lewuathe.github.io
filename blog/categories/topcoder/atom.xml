<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: TopCoder | The first cry of Atom]]></title>
  <link href="http://lewuathe.github.io/blog/categories/topcoder/atom.xml" rel="self"/>
  <link href="http://lewuathe.github.io/"/>
  <updated>2014-09-12T06:29:15+09:00</updated>
  <id>http://lewuathe.github.io/</id>
  <author>
    <name><![CDATA[Kai Sasaki]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Patterns About BFS in Competitive Programming]]></title>
    <link href="http://lewuathe.github.io/blog/2014/04/10/patterns-about-bfs-in-commetitive-programming/"/>
    <updated>2014-04-10T20:24:26+09:00</updated>
    <id>http://lewuathe.github.io/blog/2014/04/10/patterns-about-bfs-in-commetitive-programming</id>
    <content type="html"><![CDATA[<p>So let&rsquo;s go back to English from today :)</p>

<p>I solved SRM612 Div1 for practice. This problem is <a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=10543">this</a>
In this post, I left out the detail of this problem because main topic of this post is pattern of <a href="http://en.wikipedia.org/wiki/Breadth-first_search">BFS</a>.
First I tried to solve this problem with some dynamic programming algorithm. But after trying, I found BFS is sufficient algorithm
to solve. So now I rewrote my program as below.</p>

<!-- more -->


<p>```java
import java.util.<em>;
import java.math.</em>;</p>

<p>import static java.lang.Math.*;</p>

<p>public class EmoticonsDiv1 {</p>

<pre><code>public static int[] decode(int code) {
    int[] ret = new int[2];
    ret[0] = code / 10000;
    ret[1] = code % 10000;
    return ret;
}

public int printSmiles(int smiles) {
    Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;();
    int[][] state = new int[1 &lt;&lt; 1000][1 &lt;&lt; 1000];
    for (int i = 0; i &lt; 1 &lt;&lt; 1000; i++) {
        for (int j = 0; j &lt; 1 &lt;&lt; 1000; j++) {
            state[i][j] = (1 &lt;&lt; 1000);
        }
    }
</code></pre>

<p>//        state[i][j] : i = message, j = clipboard</p>

<pre><code>    state[1][0] = 0;
    q.add(1 * 10000 + 0);

    while (!q.isEmpty()) {
        int[] ret = decode(q.poll());
        int message = ret[0];
        int clipboard = ret[1];

        if (state[message][message] &gt; state[message][clipboard] + 1) {
            state[message][message] = state[message][clipboard] + 1;
            q.add(message * 10000 + message);
        }

        if (message + clipboard &lt; (1 &lt;&lt; 1000) &amp;&amp; state[message + clipboard][clipboard] &gt; state[message][clipboard] + 1) {
            state[message + clipboard][clipboard] = state[message][clipboard] + 1;
            if (message + clipboard == smiles) return state[message + clipboard][clipboard];
            q.add((message + clipboard) * 10000 + clipboard);
        }

        if (message &gt; 0 &amp;&amp; state[message - 1][clipboard] &gt; state[message][clipboard] + 1) {
            state[message - 1][clipboard] = state[message][clipboard] + 1;
            if (message - 1 == smiles) return state[message - 1][clipboard];
            q.add((message - 1) * 10000 + clipboard);
        }

    }

    return 1 &lt;&lt; 1000;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>The computing complexity of this code is O(S<sup>2</sup>). Could solve in time. After writing, I realized there are some patterns about writing BFS
in competitive programming. I want to put together these patterns in this port for the future contest.</p>

<h2>State encoding, decoding</h2>

<p>In general, BFS uses a queue data strucure. The elements of queue has to keep each state to search. In this case, each <code>message</code> and <code>clipboard</code>.
When you write software on long-term basis, you should write state class for keeping <code>message</code> and <code>clipboard</code>. But this is competitive programming.
Defining adhoc class will take you some more time to complete writing code. So you should avoid this pattern as possible.</p>

<p>The solution is encoding, decoding pattern. Default queue can only keep one <code>Integer</code> or <code>String</code>, therefore let two variables put into this one variable.
Specifically, this is.</p>

<p>```java
// Decode one integer to two interger that composes state
public static int[] decode(int code) {</p>

<pre><code>int[] ret = new int[2];
ret[0] = code / 10000;
ret[1] = code % 10000;
return ret;
</code></pre>

<p>}</p>

<p>int[] ret = decode(q.poll());
int message = ret[0];
int clipboard = ret[1];
// Encode two variables into one variable
q.add(message * 10000 + clipboard);</p>

<p>```</p>

<p>With this pattern you don&rsquo;t have to write your own state class. But this pattern has a fault. If there are more variables in a state,
decoding and encoding code becomes more complex and hard to debug. In addition to this problem, you should also know the range of input variable.
In this case, I use 10000 number to encoding and decoding, bacause input variables are included in [0, 1000]. So <code>message</code> and <code>clipboard</code> can be
separated. The selection of this base integer will be difficult as the number of state varibales are increasing.</p>

<h2>Optimization value</h2>

<p>Above case, optimization value to be submit as answer is the count of manipulation <code>state[i][j]</code>. If you can write state class, you don&rsquo;t need to
this 2 dimension array. But you couldn&rsquo;t. So with this <code>state</code>, I can realize that if I want to keep more values such as optimization value,
I can prepair external third variable instead. With this variable, you can keep more values corresponding to each state.</p>

<h2>Last but not least</h2>

<p>You should not write such codes in production software!!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM144 Div1]]></title>
    <link href="http://lewuathe.github.io/blog/2014/03/17/srm144-div1/"/>
    <updated>2014-03-17T21:57:38+09:00</updated>
    <id>http://lewuathe.github.io/blog/2014/03/17/srm144-div1</id>
    <content type="html"><![CDATA[<p>After a long time, I returned to <a href="http://www.topcoder.com/">TopCoder</a>.
I forgot to write algorithm for programming contest such as TopCoder. But previously
I realized that it is so important for me to write accurate and fast algorithm within finite time.
In order to improve my programming skill again, I returned back to the TopCoder.</p>

<!-- more -->


<p>SRM is a little hart to me, as first, I tried some practices. Today I solved SRM144 binary code problem.
This problem decode messages recursively. For example, when you get the message <code>"123210122"</code>, this is encode of
<code>"011100011"</code>. Suppose the first message is P, and second is Q. Now below equation is realized.</p>

<p><code>
P[i] = Q[i-1] + Q[i] + Q[i+1]
</code></p>

<p>With this recusive rule, you have to decode given message. My code is below.</p>

<p>```java
import java.util.<em>;
import java.math.</em>;</p>

<p>import static java.lang.Math.*;</p>

<p>public class BinaryCode {</p>

<pre><code>public String[] decode(String message) {
    // Two answers should be solved
    // Each answer is correspond to Q[0] = 0 and Q[0] = 1 case.
    String[] ans = new String[2];

    Integer start = 0;
    Boolean isOut = null;

    // Calculate two cases
    for (int i = 0; i &lt; 2; i++) {
        // In the case of negative value is received, answer should be "NONE"
        isOut = false;
        start = i;

        // For improve speed performance, I use StringBuffer
        StringBuffer p = new StringBuffer();

        // First and second factor cannot be put on inside loop bacause these are not the sum of three factors
        p.append(start.toString());
        Integer p1 = Integer.parseInt(message.substring(0, 1)) - Integer.parseInt(p.substring(0, 1));
        p.append(p1);

        // Decode each digit
        for (int j = 1; j &lt; message.length(); j++) {
            Integer d = Integer.parseInt(message.substring(j, j+1)) - Integer.parseInt(p.substring(j, j+1)) - Integer.parseInt(p.substring(j-1, j));
            if (d &lt; 0) {
                ans[i] = "NONE";
                isOut = true;
                break;
            }
            p.append(d.toString());
       }

       // Last digit is not need to retained
       if (!isOut) {
           ans[i] = p.toString().substring(0, p.length()-1);
       }

       // This is guard. But I am not satisfied with this line :(
       if (message.length() == 1 &amp;&amp; (message.charAt(0) == '2' || message.charAt(0) == '3')) {
           ans[i] = "NONE";
       }
    }

    return ans;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>I wrote this code about 30 minutes. It is not enough to fight on SRM. And in addition to this, I am not satisfied with my algorithm expecially
last clause. I don&rsquo;t want to write exceptional logic as possible. If anyone write code about this problem, please inform me and give me a chance to
look into your code.</p>

<p>Thank you.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TopCoder With IntelliJ IDEA]]></title>
    <link href="http://lewuathe.github.io/blog/2014/03/03/topcoder-with-intellij-idea/"/>
    <updated>2014-03-03T21:45:57+09:00</updated>
    <id>http://lewuathe.github.io/blog/2014/03/03/topcoder-with-intellij-idea</id>
    <content type="html"><![CDATA[<p>When you try <a href="http://www.topcoder.com/">TopCoder</a>, as you know, IDE is one of the most efficient options
to write accurate code very fast. So far, <a href="https://www.eclipse.org/">Eclipse</a> is the most famous IDE in this field.
However today, I know <a href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a> can also be the great editor to fight it out.
So I try to install TopCoder plugin into my IntelliJ IDEA which is called <a href="https://github.com/fadeyev/intellijcoder">IntelliJCoder</a>.</p>

<!-- more -->


<h2>Install</h2>

<p>By using plugin manager embedded to IntelliJ IDEA, you install IntelliJCoder. Today, its version is v1.6.
And restart your IDE.</p>

<p><img src="/images/posts/2014-03-03-intellijcoder/plugin_install.png" alt="plugin_install" /></p>

<h2>Launch Arena</h2>

<p><img src="/images/posts/2014-03-03-intellijcoder/topcoder_icon.png" alt="plugin_install" /></p>

<p>You can see TopCoder icon inside the toolbar. If you cannot see toolbar itself, click view menu and select toolbar.
Click this icon, and TopCoder arena will be launched. It might takes some minutes.</p>

<p><img src="/images/posts/2014-03-03-intellijcoder/toolbar.png" alt="toolbar" />
<img src="/images/posts/2014-03-03-intellijcoder/launch_arena.png" alt="launch_arena" /></p>

<h2>Open problems</h2>

<p>Ok now, let&rsquo;s solve any problems. In the proactive room, select one problem as you like from SRM.
Select problem, then you can see TopCoder simple editor. If you use any language except for Java, you should select Java.
And sckelton codes are written into your IntelliJ IDEA automatically. Now it&rsquo;s the time to solve problem. Hack it!</p>

<p><img src="/images/posts/2014-03-03-intellijcoder/open_problem.png" alt="open_problem" /></p>

<h2>Test and Submit</h2>

<p>Suprisingly, you can also run test codes generated from this plugin. When you build this code in IntelliJ IDEA, the test codes based on problem examples
are run. So it is easy to confirm whether your code are correct or not before submitting it.
Compiling and Submitting is the same way to ordinary one. Definitely you can solve problems faster than your rivals with this plugin.</p>

<p><img src="/images/posts/2014-03-03-intellijcoder/run_test.png" alt="run_test" /></p>

<p>Thank you.</p>
]]></content>
  </entry>
  
</feed>
